From 21f2ead6bcff90fd651a460da6850114d6552dce Mon Sep 17 00:00:00 2001
From: Raphael Mounier <mounierr07@gmail.com>
Date: Fri, 27 Sep 2024 14:57:47 +0200
Subject: [PATCH 13/15] folio: add folio_daemon for huawei phone

with minor change work also for smasung and google phone
---
 base.mk                   |   8 ++
 folio/Android.mk          |  28 ++++++
 folio/init.folio.rc       |  20 ++++
 folio/main.cpp            | 192 ++++++++++++++++++++++++++++++++++++++
 sepolicy/file_contexts    |   2 +
 sepolicy/folio_daemon.te  |  15 +++
 sepolicy/system_server.te |   1 +
 7 files changed, 266 insertions(+)
 create mode 100644 folio/Android.mk
 create mode 100644 folio/init.folio.rc
 create mode 100644 folio/main.cpp
 create mode 100644 sepolicy/folio_daemon.te
 create mode 100644 sepolicy/system_server.te

diff --git a/base.mk b/base.mk
index d04a4c5..59bdf6c 100644
--- a/base.mk
+++ b/base.mk
@@ -263,3 +263,11 @@ PRODUCT_PACKAGES += \
 # Meizu vibrator
 PRODUCT_PACKAGES += \
     android.hardware.vibrator@1.3-service.meizu
+    
+# Folio Daemon
+PRODUCT_PACKAGES += \
+    folio_daemon
+
+PRODUCT_COPY_FILES += \
+    device/phh/treble/folio/init.folio.rc:system/etc/init/init.folio.rc
+
diff --git a/folio/Android.mk b/folio/Android.mk
new file mode 100644
index 0000000..ed5b5da
--- /dev/null
+++ b/folio/Android.mk
@@ -0,0 +1,28 @@
+LOCAL_PATH := $(call my-dir)
+
+# Disabling when building with PDK (b/68767391)
+ifneq ($(TARGET_BUILD_PDK),true)
+
+include $(CLEAR_VARS)
+
+LOCAL_SHARED_LIBRARIES := \
+    libandroid \
+    libcutils \
+    liblog
+
+LOCAL_SRC_FILES := \
+    main.cpp
+
+LOCAL_C_INCLUDES :=
+
+LOCAL_CFLAGS := $(common_flags) -DLOG_TAG=\"folio_daemon\" -DLOG_NDEBUG=0
+
+LOCAL_CFLAGS += -Wall -Werror
+
+LOCAL_MODULE := folio_daemon
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_OWNER := google
+
+include $(BUILD_EXECUTABLE)
+
+endif
diff --git a/folio/init.folio.rc b/folio/init.folio.rc
new file mode 100644
index 0000000..d92c5b0
--- /dev/null
+++ b/folio/init.folio.rc
@@ -0,0 +1,20 @@
+# Copyright (C) 2008-2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+
+service vendor.folio_daemon /system/bin/folio_daemon
+    class late_start
+    user system
+    group system uhid
+    disabled
+
+on property:init.svc.zygote=running
+    start vendor.folio_daemon
+
+on property:init.svc.zygote=stopped
+    stop vendor.folio_daemon
\ No newline at end of file
diff --git a/folio/main.cpp b/folio/main.cpp
new file mode 100644
index 0000000..c3f006b
--- /dev/null
+++ b/folio/main.cpp
@@ -0,0 +1,192 @@
+/*
+ * Copyright 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+#include <linux/input.h>
+#include <linux/uinput.h>
+#include <android/looper.h>
+#include <android/sensor.h>
+#include <cutils/log.h>
+
+// Hall-effect sensor type
+#define SENSOR_HALL_TYPE 65538
+
+#define RETRY_LIMIT     120
+#define RETRY_PERIOD    30          // 30 seconds
+#define WARN_PERIOD     (time_t)300 // 5 minutes
+
+/*
+ * This simple daemon listens for events from the Hall-effect sensor and writes
+ * the appropriate SW_LID event to a uinput node. This allows the screen to be
+ * locked with a magnetic folio case.
+ */
+int main(void) {
+    int uinputFd;
+    int err;
+    struct uinput_user_dev uidev;
+    ASensorManager *sensorManager = nullptr;
+    ASensorRef hallSensor;
+    ALooper *looper;
+    ASensorEventQueue *eventQueue = nullptr;
+    int32_t hallMinDelay = 0;
+    time_t lastWarn = 0;
+    int attemptCount = 0;
+    ASensorList sensor_list;
+    int sensor_count = 0;
+
+    ALOGI("Started");
+
+    uinputFd = TEMP_FAILURE_RETRY(open("/dev/uinput", O_WRONLY | O_NONBLOCK));
+    if (uinputFd < 0) {
+        ALOGE("Unable to open uinput node: %s", strerror(errno));
+        goto out;
+    }
+
+    err = TEMP_FAILURE_RETRY(ioctl(uinputFd, UI_SET_EVBIT, EV_SW))
+        | TEMP_FAILURE_RETRY(ioctl(uinputFd, UI_SET_EVBIT, EV_SYN))
+        | TEMP_FAILURE_RETRY(ioctl(uinputFd, UI_SET_SWBIT, SW_LID));
+    if (err != 0) {
+        ALOGE("Unable to enable SW_LID events: %s", strerror(errno));
+        goto out;
+    }
+
+    memset(&uidev, 0, sizeof (uidev));
+    snprintf(uidev.name, UINPUT_MAX_NAME_SIZE, "uinput-folio");
+    uidev.id.bustype = BUS_VIRTUAL;
+    uidev.id.vendor = 0;
+    uidev.id.product = 0;
+    uidev.id.version = 0;
+
+    err = TEMP_FAILURE_RETRY(write(uinputFd, &uidev, sizeof (uidev)));
+    if (err < 0) {
+        ALOGE("Write user device to uinput node failed: %s", strerror(errno));
+        goto out;
+    }
+
+    err = TEMP_FAILURE_RETRY(ioctl(uinputFd, UI_DEV_CREATE));
+    if (err < 0) {
+        ALOGE("Unable to create uinput device: %s", strerror(errno));
+        goto out;
+    }
+
+    ALOGI("Successfully registered uinput-folio for SW_LID events");
+
+    // Get Hall-effect sensor events from the NDK
+    sensorManager = ASensorManager_getInstanceForPackage(nullptr);
+    looper = ALooper_forThread();
+    if (looper == nullptr) {
+        looper = ALooper_prepare(ALOOPER_PREPARE_ALLOW_NON_CALLBACKS);
+    }
+
+    eventQueue = ASensorManager_createEventQueue(sensorManager, looper, 0, NULL,
+                                                 NULL);
+
+    sensor_count = ASensorManager_getSensorList(sensorManager, &sensor_list);
+    ALOGI("Found %d sensors\n", sensor_count);
+    for (int i = 0; i < sensor_count; i++) {
+        ALOGI("Found %s - %d \n", ASensor_getName(sensor_list[i]), ASensor_getType(sensor_list[i]));
+    }
+    
+    /*
+     * As long as we are unable to get the sensor handle, periodically retry
+     * and emit an error message at a low frequency to prevent high CPU usage
+     * and log spam. If we simply exited with an error here, we would be
+     * immediately restarted and fail in the same way indefinitely.
+     */
+    while (true) {
+        time_t now = time(NULL);
+        hallSensor = ASensorManager_getDefaultSensor(sensorManager,
+                                                     SENSOR_HALL_TYPE);
+        if (hallSensor != nullptr) {
+            hallMinDelay = ASensor_getMinDelay(hallSensor);
+            break;
+        }
+
+        if (++attemptCount >= RETRY_LIMIT) {
+            ALOGE("Retries exhausted; exiting");
+            goto out;
+        } else if (now > lastWarn + WARN_PERIOD) {
+            ALOGE("Unable to get Hall-effect sensor");
+            lastWarn = now;
+        }
+
+        sleep(RETRY_PERIOD);
+    }
+
+    err = ASensorEventQueue_registerSensor(eventQueue, hallSensor,
+                                           hallMinDelay, 10000);
+    if (err < 0) {
+        ALOGE("Unable to register for Hall-effect sensor events");
+        goto out;
+    }
+
+    ALOGI("Starting polling loop");
+
+    // Polling loop
+    while (ALooper_pollAll(-1, NULL, NULL, NULL) == 0) {
+        int eventCount = 0;
+        ASensorEvent sensorEvent;
+        while (ASensorEventQueue_getEvents(eventQueue, &sensorEvent, 1) > 0) {
+            // 1 means closed; 0 means open
+            int isClosed = sensorEvent.data[0] > 0.0f ? 1 : 0;
+            struct input_event event;
+            event.type = EV_SW;
+            event.code = SW_LID;
+            event.value = isClosed;
+            err = TEMP_FAILURE_RETRY(write(uinputFd, &event, sizeof (event)));
+            if (err < 0) {
+                ALOGE("Write EV_SW to uinput node failed: %s", strerror(errno));
+                goto out;
+            }
+
+            // Force a flush with an EV_SYN
+            event.type = EV_SYN;
+            event.code = SYN_REPORT;
+            event.value = 0;
+            err = TEMP_FAILURE_RETRY(write(uinputFd, &event, sizeof (event)));
+            if (err < 0) {
+                ALOGE("Write EV_SYN to uinput node failed: %s",
+                      strerror(errno));
+                goto out;
+            }
+
+            ALOGI("Sent lid %s event", isClosed ? "closed" : "open");
+            eventCount++;
+        }
+
+        if (eventCount == 0) {
+            ALOGE("Poll returned with zero events: %s", strerror(errno));
+            break;
+        }
+    }
+
+out:
+    // Clean up
+    if (sensorManager != nullptr && eventQueue != nullptr) {
+        ASensorManager_destroyEventQueue(sensorManager, eventQueue);
+    }
+
+    if (uinputFd >= 0) {
+        close(uinputFd);
+    }
+
+    // The loop can only be exited via failure or signal
+    return 1;
+}
diff --git a/sepolicy/file_contexts b/sepolicy/file_contexts
index 3bc437c..8500389 100644
--- a/sepolicy/file_contexts
+++ b/sepolicy/file_contexts
@@ -20,3 +20,5 @@
 
 /dev/smcinvoke u:object_r:smcinvoke_device:s0
 /system/bin/hw/android\.hardware\.bluetooth\.audio-service-system u:object_r:hal_audio_sysbta_exec:s0
+
+/system/bin/folio_daemon          u:object_r:folio_daemon_exec:s0
diff --git a/sepolicy/folio_daemon.te b/sepolicy/folio_daemon.te
new file mode 100644
index 0000000..f48a3b2
--- /dev/null
+++ b/sepolicy/folio_daemon.te
@@ -0,0 +1,15 @@
+type folio_daemon, domain, coredomain;
+type folio_daemon_exec, system_file_type, exec_type, file_type;
+
+init_daemon_domain(folio_daemon)
+
+allow folio_daemon binder_device:chr_file rw_file_perms;
+allow folio_daemon uhid_device:chr_file rw_file_perms;
+
+allow folio_daemon system_server:unix_stream_socket rw_socket_perms_no_ioctl;
+
+binder_use(folio_daemon)
+binder_call(folio_daemon, system_server)
+
+allow folio_daemon sensorservice_service:service_manager find;
+allow folio_daemon permission_service:service_manager find;
diff --git a/sepolicy/system_server.te b/sepolicy/system_server.te
new file mode 100644
index 0000000..389fee0
--- /dev/null
+++ b/sepolicy/system_server.te
@@ -0,0 +1 @@
+binder_call(system_server, folio_daemon)
-- 
2.25.1

